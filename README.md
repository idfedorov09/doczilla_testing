# Решения тестовых задач на позицию Junior Fullstack developer, Doczilla

В данном репозитории представлены решения трех задач на позицию Junior Fullstack разработчика. Так как в репозитории работаю только я, то решил ограничиться коммитами, без использования пулл реквестов. Решения задач хранятся в папках `problem_1`, `problem_2` и `problem_3`. Суффикс названия соответствует номеру задания.

Условия можно найти [здесь](https://candy-street-1b5.notion.site/Junior-0bfd0699f42245c59323e210f3bd121d).

## Задание 1. Анализ директории

Решение реализовано на чистой `Java 17` с использованием системы сборки `Gradle`. 

### Запуск
Из папки `problem_1` запустите следующую команду
```bash
java -jar problem_1.jar --folder=$SOME_PATH
```
где `$SOME_MATH` - это путь к папке, которая подвергается анализу. В `problem_1` находятся папки `test_folder` и `test_folder2`, которые можно можно использовать в качестве тестовых. Например, для запуска анализа содержимого папки `test_folder2` можно использовать следующий код:
```bash
cd problem_1;
java -jar problem_1.jar --folder=./test_folder2
```

### Результат
В результате выполнения программы могут быть сгенерированы следующие файлы:
- `concatenate_all.txt` -- представляет собой конкатенацию всех внутренних файлов, отсортированных по имени. Генерируется всегда. Если такой файл уже есть, то он будет перезаписан
- `sorted_list.txt` -- представляет собой требуемый список файлов на основе зависимостей. Элемент списка представляется в виде относительного пути к соответствующему файлу. Генерируется в случае, если нет циклических зависимостей
- `cycle_by_requires.txt` -- представляет собой список файлов, которые образуют циклическую зависимость. Генерируется в случае, если есть циклические зависимости

### Что под капотом
Сначала программа рекурсивно обходит все вложенные директории, находя в них файлы. Строится массив полученных файлов. Элементы массива представляются классом `ru.doczilla.testing.FileDescNode`. Далее следует конкатенация файлов с предварительной сортировкой данного массива по имени в лексикографическом порядке и сохранение результата в `concatenate_all.txt`. Запись идет "вживую", построчно, что позволяет не перегружать ОЗУ. Далее строится граф зависимостей -- просто пробегаемся по полученным файлам и ищем строки вида `require 'some-path'`. Граф хранится в виде списоков смежности. После чего поиском в глубину пробуем выявить цикл. Если цикл есть, то записываем результат в `cycle_by_requires.txt`. Если нет -- то гуляя по графу, строим необходимый список зависимостей, и записываем результат в файл `sorted_list.txt`.

## Задание 2. Управление студентами
Серверная часть реализована на `Kotlin 1.9.20` с использованием `JDBC`, sql-запросы соответсвенно писались вручную. В качестве базы данных используется `PostgreSQL`.
Клиентская часть реализована на `JavaScript` с использованием `Fetch API`  для запросов к серверу.

### Запуск
Из папки `problem_2` запустите следующую команду
```bash
java -jar student-server.jar
```
Эта команда запустит сервер по адресу `localhost:8001`. Для перехода на клиентскую часть, после запуск нужно перейти по адресу [localhost:8001](http://localhost:8001/). Там будет представлен интерфейс для взаимодействия со списками студентов. 
В данном случае, сервер будет обращаться к моей базе данных. Если хочется другую, то в `src/main/resources` нужно создать файл `application.properties` следующего вида:
```application.properties
pg.url=...
pg.username=...
pg.password=...
```
В базе данных должна присутсвовать таблица `students_table`:
```sql
CREATE TABLE students_table (
	id SERIAL PRIMARY KEY,
	name TEXT,
	second_name TEXT,
	middle_name TEXT,
	birthday TEXT,
	study_group TEXT
)
```
После того, как убедитесь, что таблица присутствует, необходимо собрать проект `./gradlew build` и запустить файл `build/libs/problem_2-all.jar`.

### Что под капотом
Клиент делает запросы к серверу. У сервера есть ручка `/api/students/`, к которой можно обращаться методами `GET`, `PUT`, `DELETE`. Первый метод вернет список всех студентов. Второй метод добавит нового студента в базу данных. Третий метод удаляет студента по заданному `id`.
Студент представляется следующей сущностью:
```json
{
	"id": uuid,
	"name": string,
	"second_name": string,
	"middle_name": string,
	"birthday": string,
	"study_group": string
}
```
`GET` запрос возвращает массив таких записей. `PUT` запрос должен содержать в теле запись студента (с осутсвующим или равным `null` айдишником). `DELETE` запрос должен содержать `id` студента в качестве параметра.
